(macro=> let* (vars body...)
  (=> expand (clauses body)
    (let ((first-clause (first clauses))
          (rest-clauses (all-but-first clauses)))
         (if (empty? rest-clauses)
             `(let (,first-clause) ,@body)
             `(let (,first-clause) ,(expand rest-clauses body)))))
  (expand vars body))



(macro=> cond (args...)
  (if (or (empty? args)
          (not (and (map list? args)))
          (!= (first (last args)) `else)
          (not (reduce + (map #(= (len _) 2) args))))
      (error "invalid pairs passed to cond"))
  (=> predicate-clause (exp) (first exp))
  (=> consequent-clause (exp) (last exp))
  (=> else-clause? (exp) (= (predicate-clause exp) `else))
  (=> make-if (pred conseq alt) `(if ,pred ,conseq ,alt))
  (=> expand (clauses)
    (if (empty? clauses)
        #f
        (let ((first-clause (first clauses))
              (rest (all-but-first clauses)))
              (if (else-clause? first-clause)
                  (consequent-clause first-clause)
                  (make-if (predicate-clause first-clause)
                           (consequent-clause first-clause)
                           (expand rest))))))
  (expand args))


(macro=> switch (thing cases...)
  (if (or (empty? cases)
          (!= (first (last cases)) `default))
      (error "invalid cases"))
  (=> format-case (c)
    (let ((value (first c))
          (consequent (last c)))
      (if (= value `default)
          `(else ,consequent)
          `((= ,thing ,value) ,consequent))))
  `(cond ,@(map format-case cases)))
